
import re

file_path = 'src/data/translations.ts'

def fix_translations():
    with open(file_path, 'r', encoding='utf-8') as f:
        content = f.read()

    # 1. Remove detached conversation blocks at the end of the file (after hi block)
    # The hi block ends around line 2251 with `}}`.
    # Detached blocks are `conversation: { ... }};` or `}}, conversation: { ... }`
    
    # We'll just truncate the file after the `hi` block closes.
    # Find `hi: {`
    hi_start = content.find('    hi: {')
    if hi_start == -1:
        print("Could not find hi block")
        return

    # Find end of hi block
    # Count braces
    idx = hi_start + len('    hi: {')
    brace_count = 1
    hi_end = -1
    while idx < len(content):
        if content[idx] == '{':
            brace_count += 1
        elif content[idx] == '}':
            brace_count -= 1
            if brace_count == 0:
                hi_end = idx + 1 # Include the closing brace
                break
        idx += 1
    
    if hi_end != -1:
        # Everything after hi_end should be just `\n}` (closing the main export object)
        # But we have junk.
        # We also need to Make sure the Main Object closes.
        # The file structure is `export const translations = { ... }`
        # So we need one more `}`.
        
        # Check what's after hi_end
        trailing = content[hi_end:]
        # If it contains "conversation:", it's junk.
        if 'conversation:' in trailing:
            print("Found detached conversation blocks. Removing them.")
            content = content[:hi_end] + "\n}"
        else:
            # Maybe it's already clean or the junk is inside?
            pass

    # 2. Deduplicate conversation blocks inside languages
    # Regex to find `conversation: { ... }` repeated
    # We will replace multiple occurrences with a single one.
    # Since capturing the content of `conversation` is hard with regex (nested braces),
    # we will rely on the fact that my script inserted them with specific indentation.
    
    # Pattern: `(,\s*conversation: \{[\s\S]*?^\s*\})+`
    # We need to be careful not to match too much.
    # The inserted block ends with `        }` (8 spaces indentation).
    
    # Let's try to fix `zh` first.
    # Find `zh` block.
    # Replace the `conversation` repetitions.
    
    def dedupe_conversation(text, lang_name):
        # Regex for conversation block inserted by script
        # matches `        conversation: {` ... `        }`
        # We specifically look for the structure generated by format_ts_object
        regex = r'(,\s+conversation: \{[\s\S]*?^\s{8}\})+'
        
        # Find all matches in the lang block
        # We need to iterate over languages to avoid crossing boundaries
        pass

    # Better approach:
    # Iterate key languages, parse their content, dedupe specific keys.
    
    languages = ['zh', 'zh-TW', 'hi']
    
    for lang in languages:
        # Find start
        pattern_str = rf"^\s*(['\"]?){re.escape(lang)}\1:\s*\{{"
        match = re.search(pattern_str, content, re.MULTILINE)
        if not match: continue
        
        start_idx = match.start()
        # Find end
        idx = match.end()
        brace_count = 1
        end_idx = -1
        while idx < len(content):
            if content[idx] == '{':
                brace_count += 1
            elif content[idx] == '}':
                brace_count -= 1
                if brace_count == 0:
                    end_idx = idx + 1
                    break
            idx += 1
            
        if end_idx == -1: continue
        
        block_content = content[start_idx:end_idx]
        
        # Dedupe Categories Intro/HowToLearn
        # They appear as `            intro: "...",` repeated.
        keys_to_dedupe = ['intro', 'howToLearn', 'focusTitle', 'focusDesc', 'speakTitle', 'speakDesc']
        
        cleaned_block = block_content
        for key in keys_to_dedupe:
            # Regex to find `key: "...",`
            # We want to keep the FIRST one and remove subsequent ones.
            # Or just replace the whole sequence of repetitions with one.
            key_pattern = rf'(\s+{key}: ".*?",)+'
            
            def replace_dedupe(m):
                # Return just one instance (the first one)
                # m.group(0) is the whole match (multiple lines)
                # Split by comma+newline?
                # Actually, simply taking the first line of the match might work if they are identical?
                # But regex `(\s+key: ".*?",)+` matches consecutive lines.
                # So we just return the first capture group?
                # Wait, `(group)+` only captures the LAST group in Python?
                # No, we want the text.
                full_match = m.group(0)
                # Split by `,\n` maybe?
                parts = full_match.split(',\n')
                # Return the first part + `,\n`
                return parts[0] + ',\n'
                
            # cleaned_block = re.sub(key_pattern, replace_dedupe, cleaned_block, flags=re.DOTALL) 
            # DOTALL is dangerous/not needed if `.` matches non-newline (default).
            # ".*?" inside quotes matches content.
            
            # Simple approach: split block by lines, filter duplicates?
            pass

        # Parse lines
        lines = block_content.split('\n')
        new_lines = []
        seen_keys = set()
        # We only care about specific keys in specific scopes.
        # This is getting parsed-heavy.
        
        # Regex replacement IS safer for specific repetitions created by my script.
        # The script appended:
        # `            intro: "...",`
        # `            howToLearn: "...",`
        # ...
        
        # Let's clean `categories` specifically.
        # Find `categories: {` ... `}`
        # Inside it, dedupe.
        
        # 1. Clean Categories
        cat_match = re.search(r'categories: \{([\s\S]*?)\}', block_content)
        if cat_match:
            cat_body = cat_match.group(1)
            # Find duplicate lines for our specific keys
            clean_cat_body = cat_body
            for key in keys_to_dedupe:
                k_p = rf'(\s+{key}: "[^"]*",?)+'
                clean_cat_body = re.sub(k_p, lambda m: m.group(0).split('\n')[0].rstrip(',') + ',', clean_cat_body)
            
            # Replace in block
            cleaned_block = cleaned_block.replace(cat_body, clean_cat_body)

        # 2. Clean Conversation
        # Conversation blocks are `        conversation: { ... }`
        # Find all occurrences
        conv_regex = r'(,\s+conversation: \{[\s\S]*?^\s{8}\})+'
        # If there are multiple `conversation` blocks (separated by comma/newlines), replace with single.
        
        # We need to construct the Single Conversation Block for this lang to replace with.
        # Or just keep the first one found?
        # The regex `(pattern)+` matches consecutive occurrences.
        # So we can replace with just one `pattern`.
        
        def reduce_conv(m):
            # return single instance
            # split by `},`
            text = m.group(0)
            # Find the first `}` at line start?
            # It's indentation sensitive.
            # Assuming standard formatting: `\n        }`
            end_marker = '\n        }'
            first_end = text.find(end_marker)
            if first_end != -1:
                return text[:first_end + len(end_marker)]
            return text

        cleaned_block = re.sub(conv_regex, reduce_conv, cleaned_block, flags=re.MULTILINE)
        
        # Also, check if `zh-TW` needs the conversation block ADDED (if it was detached and lost in step 1).
        if lang == 'zh-TW':
            # Check if conversation exists
            if 'conversation: {' not in cleaned_block:
                # We need to add it.
                # Use the hardcoded data for zh-TW
                zh_tw_conv = """
        conversation: {
            back: "返回分類",
            titleSuffix: "會話",
            subtitle: "練習常見問答",
            noData: "該類別暫無會話數據。",
            question: "問題",
            answer: "回答",
            option: "選項",
            mainTitle: "會話練習",
            mainDesc: "學習各種情況下的常見問答。",
            start: "開始練習"
        }"""
                # Insert before the last brace of the block
                last_brace = cleaned_block.rfind('}')
                cleaned_block = cleaned_block[:last_brace] + "," + zh_tw_conv + "\n    }"

        # Update content using string replacement (careful with multiple matches)
        # Since we use indices, we can splice.
        # But indices shifted if we modified `content` in previous loop.
        # Actually `start_idx` is based on `content`.
        # So we should rebuild `content` piece by piece or use a delta.
        
        # Easier: Re-read `content` each iteration? No, inefficient and hard.
        # Map: `original_range` -> `new_text`.
        # Then apply from end to start.
        pass

    # Let's apply changes from end to Start (hi -> zh-TW -> zh).
    # Since I sorted languages logically, I should reverse them?
    # List is `['zh', 'zh-TW', 'hi']`.
    # `hi` is last. `zh` is first.
    # So I should process `hi`, then `zh-TW`, then `zh`.
    
    languages = ['hi', 'zh-TW', 'zh']
    
    # We need to RE-FIND the blocks each time because content changes?
    # If I modify `hi`, does `zh` index change? No, `zh` is before `hi`.
    # So order: `hi`, `zh-TW`, `zh` is safe.
    
    for lang in languages:
        # Re-find block (regex)
        pattern_str = rf"^\s*(['\"]?){re.escape(lang)}\1:\s*\{{"
        match = re.search(pattern_str, content, re.MULTILINE)
        if not match: 
            print(f"Skipping {lang} - not found")
            continue
        
        start_idx = match.start()
        # Find end
        idx = match.end()
        brace_count = 1
        end_idx = -1
        while idx < len(content):
            if content[idx] == '{':
                brace_count += 1
            elif content[idx] == '}':
                brace_count -= 1
                if brace_count == 0:
                    end_idx = idx + 1
                    break
            idx += 1
            
        if end_idx == -1: continue
        
        block_content = content[start_idx:end_idx]
        original_block = block_content
        
        # Perform cleanups on `block_content`
        # 1. Categories
        cat_match = re.search(r'categories: \{([\s\S]*?)\}', block_content)
        if cat_match:
            cat_body = cat_match.group(1)
            clean_cat_body = cat_body
            for key in keys_to_dedupe:
                # Regex matches one or more repetitions of `key: "...",`
                k_p = rf'(\s+{key}: "[^"]*",?)+'
                clean_cat_body = re.sub(k_p, lambda m: m.group(0).split('\n')[0].rstrip(',') + ',', clean_cat_body)
            
            block_content = block_content.replace(cat_body, clean_cat_body)

        # 2. Conversation
        conv_regex = r'(,\s+conversation: \{[\s\S]*?^\s{8}\})+'
        def reduce_conv(m):
            text = m.group(0)
            end_marker = '\n        }'
            first_end = text.find(end_marker)
            if first_end != -1:
                return text[:first_end + len(end_marker)]
            return text
        
        block_content = re.sub(conv_regex, reduce_conv, block_content, flags=re.MULTILINE)
        
        # 3. Add Missing Conversation (for zh-TW)
        if lang == 'zh-TW':
            if 'conversation: {' not in block_content:
                zh_tw_conv = """
        conversation: {
            back: "返回分類",
            titleSuffix: "會話",
            subtitle: "練習常見問答",
            noData: "該類別暫無會話數據。",
            question: "問題",
            answer: "回答",
            option: "選項",
            mainTitle: "會話練習",
            mainDesc: "學習各種情況下的常見問答。",
            start: "開始練習"
        }"""
                last_brace = block_content.rfind('}')
                block_content = block_content[:last_brace] + "," + zh_tw_conv + "\n    }"

        # Replace in content
        if block_content != original_block:
            content = content[:start_idx] + block_content + content[end_idx:]
            print(f"Cleaned {lang}")

    with open(file_path, 'w', encoding='utf-8') as f:
        f.write(content)
    print("Fixed translations.")

if __name__ == "__main__":
    fix_translations()
